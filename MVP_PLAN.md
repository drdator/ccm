# CCM MVP Implementation Plan

## Overview
CCM (Claude Command Manager) will be a package manager for Claude Code custom commands, enabling users to discover, share, and manage slash commands for Claude Code.

## Key Insight
CCM provides a dual structure: publishers develop commands in a clean root structure (`commands/`, `ccm.json`) while consumers install and use commands in Claude Code's `.claude/` structure. This separation creates a clear distinction between command development and usage.

## MVP Scope (v0.1.0)

### Core Features
1. **Project Initialization** - `ccm init` to set up project structure ✅
2. **Command Installation/Removal** - Download and install commands with symlinks
3. **Command Publishing** - Share commands to central repository
4. **Command Discovery** - Search and browse available commands
5. **Version Management** - Basic versioning with ccm.json dependency manifest
6. **CLI Interface** - Simple command-line tool ✅

### Enhanced Architecture (Added)
- **Dual Structure** - Publishers: root structure, Consumers: `.claude/` structure
- **Package Namespacing** - Commands accessed as `/package-name/command`
- **Directory Symlinks** - Entire package directories symlinked for clean organization
- **Simplified Configuration** - Single dependencies field (no devDependencies)

### Out of Scope for MVP
- GUI interface
- Team/organization features
- Advanced templating
- Command dependencies between packages
- Paid/premium commands

## Technical Architecture

### 1. Dual Project Structure

#### Publisher Structure (Creating Commands)
```
my-command-package/
├── commands/           # Command files being developed
│   ├── git-helper.md
│   └── code-review.md
├── ccm.json           # Package manifest
└── README.md
```

#### Consumer Structure (Using Commands)
```
my-project/
├── .claude/
│   ├── commands/           # Claude Code reads from here
│   │   ├── my-command.md          # User-created command
│   │   ├── dev-tools/ -> ../installed/dev-tools/     # Package symlink
│   │   └── utils/ -> ../installed/utils/             # Package symlink
│   ├── installed/          # CCM-managed commands (git-ignored)
│   │   ├── dev-tools/
│   │   │   ├── git-helper.md
│   │   │   └── code-review.md
│   │   ├── utils/
│   │   │   └── formatter.md
│   │   └── .ccm-metadata.json     # Installation metadata
│   ├── ccm.json           # Dependency manifest
│   └── .gitignore         # Auto-generated by CCM
└── src/                    # Project files
```

### 2. ccm.json Format

#### Publisher ccm.json (Package Manifest)
```json
{
  "name": "dev-tools",
  "version": "1.2.0",
  "description": "Development productivity commands"
}
```

#### Consumer ccm.json (Dependency Manifest)
```json
{
  "name": "consumer-project",
  "version": "1.0.0",
  "dependencies": {
    "dev-tools": "^1.2.0",
    "code-review": "^2.0.0",
    "test-utils": "^1.0.0"
  }
}
```

### 3. Command Format
```markdown
# git-commit-helper.md (command file)
---
description: Generate semantic git commit messages
author: Developer Name
tags: ["git", "productivity"]
arguments: true
---

# Git Commit Helper

Based on the git diff output below, generate a semantic commit message:

$ARGUMENTS
```

Commands use frontmatter for metadata and are accessed in Claude Code as:
- `/dev-tools/git-commit-helper` (with package namespace)
- Package directories are symlinked to maintain clean organization

### 4. System Components

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│   CCM CLI       │────▶│  CCM Registry    │────▶│  Cloud Storage  │
│  (Node.js)      │     │   (REST API)     │     │   (Commands)    │
└─────────────────┘     └──────────────────┘     └─────────────────┘
         │                       │
         ▼                       ▼
┌─────────────────┐     ┌──────────────────┐
│ .claude/        │     │   PostgreSQL     │
│ ├─commands/     │     │   (metadata)     │
│ ├─installed/    │     │                  │
│ └─ccm.json      │     │                  │
└─────────────────┘     └──────────────────┘
```

### 5. Monorepo Structure
```
ccm/
├── cli/              # CLI package
│   ├── src/          # CLI source code
│   └── package.json
├── api/              # API package
│   ├── src/          # API source code
│   └── package.json
├── package.json      # Root monorepo config
└── README.md
```

## Implementation Steps

### Phase 1: CLI Foundation

#### Step 1.1: Project Setup ✅
- [x] Initialize Node.js project with TypeScript
- [x] Set up monorepo structure (cli/ and api/ folders)
- [x] Configure build toolchain (TypeScript compiler)
- [ ] Configure testing framework (Jest)
- [ ] Set up linting and formatting (ESLint, Prettier)

#### Step 1.2: CLI Framework ✅
- [x] Implement commander.js structure
- [x] Create command routing system
- [x] Add configuration management (ccm.json)
- [x] Implement logging and error handling

#### Step 1.3: Local Command Management ✅
- [x] Implement dual command scanning (local vs installed)
- [x] Create command metadata parser with frontmatter support
- [x] Build namespaced command listing functionality
- [x] Add package-aware command detection

#### Step 1.4: Project Initialization ✅
- [x] Implement `ccm init` command for publisher workflow
- [x] Create simplified ccm.json manifest system
- [x] Set up root structure (commands/, ccm.json) for publishers
- [x] Consumer structure (.claude/) auto-created on install
- [x] Add metadata tracking for installed packages

**Deliverable**: `ccm list` and `ccm init` commands working locally ✅

### Phase 2: Registry API

#### Step 2.1: API Infrastructure ✅
- [x] Set up Express.js API server
- [x] Configure dual database support (SQLite for dev, PostgreSQL for prod)
- [x] Implement database migrations
- [x] Auto-initialization for development

#### Step 2.2: Core API Endpoints ✅
```
POST   /api/auth/register     - User registration
POST   /api/auth/login        - User login
GET    /api/commands          - List/search commands
GET    /api/commands/:name    - Get command details
POST   /api/commands          - Publish command
GET    /api/commands/:name/download - Download command files
```

#### Step 2.3: Database Schema
```sql
-- users table
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- commands table
CREATE TABLE commands (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  version VARCHAR(20) NOT NULL,
  description TEXT,
  author_id INTEGER REFERENCES users(id),
  downloads INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(name, version)
);

-- command_files table
CREATE TABLE command_files (
  id SERIAL PRIMARY KEY,
  command_id INTEGER REFERENCES commands(id),
  filename VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  file_hash VARCHAR(64) NOT NULL
);

-- tags table
CREATE TABLE tags (
  id SERIAL PRIMARY KEY,
  command_id INTEGER REFERENCES commands(id),
  tag VARCHAR(50) NOT NULL
);
```

#### Step 2.4: Authentication ✅
- [x] Implement JWT token generation
- [x] Add API key support for CLI authentication
- [x] Create middleware for protected routes
- [x] Implement rate limiting

**Deliverable**: Working API with authentication ✅

### Phase 3: Command Publishing ✅

#### Step 3.1: CLI Publishing Flow ✅
- [x] Implement `ccm init` to create publisher structure
- [x] Add `ccm publish` command with dry-run support
- [x] Create command packaging logic from root commands/ directory
- [x] Implement file upload to registry with authentication

#### Step 3.2: Registry Publishing ✅
- [x] Validate command package structure via API
- [x] Check for naming conflicts with existing packages
- [x] Store command metadata in database
- [x] Store command files directly in database

#### Step 3.3: Versioning ✅
- [x] Implement semantic versioning validation
- [x] Add version conflict resolution (reject duplicates)
- [x] Create version history tracking per package

**Deliverable**: `ccm publish` command working end-to-end ✅

### Phase 4: Command Installation ✅

#### Step 4.1: Search Implementation ✅
- [x] Add `ccm search <query>` command
- [x] Implement full-text search in registry (name + description)
- [x] Add pagination support (limit/offset)
- [x] Support for basic query matching

#### Step 4.2: Installation Flow ✅
- [x] Implement `ccm install <package>` command
- [x] Download command files from registry
- [x] Create namespaced directories in `.claude/installed/`
- [x] Symlink entire package directories to `.claude/commands/`
- [x] Handle version specifications

#### Step 4.3: Dependency Resolution ✅
- [x] Track installed commands in ccm.json dependencies
- [x] Implement directory symlink management for packages
- [x] Track installed packages with metadata
- [x] Auto-create consumer structure on first install
- [ ] Implement `ccm uninstall <command>` ⏳
- [ ] Add update checking mechanism ⏳

**Deliverable**: Core install functionality complete ✅

### Phase 5: Polish & Launch

#### Step 5.1: User Experience
- [ ] Add progress indicators for downloads
- [ ] Implement helpful error messages
- [ ] Create interactive prompts where needed
- [ ] Add command validation before publish

#### Step 5.2: Documentation
- [ ] Write comprehensive README
- [ ] Create getting started guide
- [ ] Document command creation process
- [ ] Add API documentation

#### Step 5.3: Infrastructure
- [ ] Set up production hosting (Vercel/Railway)
- [ ] Configure domain and SSL
- [ ] Implement monitoring and logging
- [ ] Create backup strategy

#### Step 5.4: Testing & QA
- [ ] Write unit tests (80% coverage target)
- [ ] Add integration tests
- [ ] Perform security audit
- [ ] Beta testing with select users

**Deliverable**: Production-ready MVP

## Infrastructure Requirements

### Hosting Stack (Recommended)
- **API**: Vercel or Railway (Node.js hosting)
- **Database**: Supabase or Neon (PostgreSQL)
- **File Storage**: Cloudflare R2 or AWS S3
- **CDN**: Cloudflare
- **Domain**: ccm.dev or similar

### Estimated Costs (Monthly)
- API Hosting: $20-50
- Database: $25
- Storage/CDN: $5-10
- Domain: $1
- **Total**: ~$60/month for MVP

## Success Metrics

### Launch Goals (First 30 days)
- 100+ registered users
- 50+ published commands
- 500+ command installations
- 5+ active contributors

### Quality Metrics
- < 2s command installation time
- 99.9% API uptime
- < 100ms search response time
- Zero critical security issues

## Risk Mitigation

### Technical Risks
1. **Command Conflicts**: Implement namespacing (user/command)
2. **Malicious Commands**: Add reporting system and moderation
3. **API Abuse**: Rate limiting and API keys
4. **Data Loss**: Regular backups and version control

### Adoption Risks
1. **Low Usage**: Focus on high-quality seed commands
2. **Complex Setup**: One-line installer script
3. **Poor Discovery**: Good search and curation

## Post-MVP Roadmap

### Version 0.2.0
- Web interface for browsing commands
- Command collections/bundles
- User profiles and statistics
- Command ratings and reviews

### Version 0.3.0
- VSCode extension
- Team/organization accounts
- Private command repositories
- Advanced templating system

## Development Timeline

| Phase | Focus | Deliverable | Status |
|-------|-------|-------------|--------|
| 1 | CLI Foundation | Dual structure command management | ✅ **COMPLETE** |
| 2 | Registry API | Working API with auth | ✅ **COMPLETE** |
| 3 | Publishing | Package publishing flow | ✅ **COMPLETE** |
| 4 | Installation | Search, install, namespacing | ✅ **COMPLETE** |
| 5 | Polish & Launch | Production MVP | 🔄 **IN PROGRESS** |

## Current Status (Updated)

### ✅ **Completed (MVP Core Features)**
- **Dual Structure**: Publisher (root) vs Consumer (`.claude/`) workflows
- **CLI Foundation**: Complete command-line interface with commander.js
- **Package Namespacing**: Commands accessed as `/package/command`
- **Project Initialization**: `ccm init` creates publisher structure
- **Publishing Flow**: `ccm publish` with dry-run and authentication
- **Installation System**: `ccm install` with directory symlinks
- **Search Functionality**: `ccm search` with pagination
- **Registry API**: Full backend with SQLite/PostgreSQL support
- **Authentication**: JWT tokens and API keys for CLI access
- **Command Scanning**: Dual scanning (local vs installed packages)

### 🔄 **In Progress/Polish Phase**
- **Example Package**: Ready-to-test hello-world commands
- **Documentation**: Comprehensive E2E workflow guides
- **Testing**: API test suite complete, CLI integration testing

### ⏳ **Remaining MVP Tasks**
1. **Add `ccm uninstall`**: Remove installed packages
2. **Update checking**: `ccm outdated` and `ccm update` commands
3. **Production deployment**: API hosting and domain setup
4. **CLI distribution**: npm package publishing

### 🚀 **Ready for Beta Testing**
- Complete end-to-end workflow (init → publish → install → use)
- Dual structure supports both publishers and consumers
- Package namespacing prevents command conflicts
- Example package ready for testing (`example-commands/`)
- Comprehensive documentation and workflow guides

## Architecture Decisions Made

### 1. **Monorepo Structure**
- Separated CLI and API into distinct packages
- Shared configuration and documentation at root level
- Independent versioning and deployment capabilities

### 2. **Dual Structure Architecture**
- **Publisher Workflow**: Clean root structure (commands/, ccm.json) for development
- **Consumer Workflow**: `.claude/` structure for usage, auto-created on install
- **Package Namespacing**: Commands accessed as `/package/command` to prevent conflicts
- **Directory Symlinks**: Entire package directories symlinked for organization

### 3. **Simplified Package Management**
- **Semantic Versioning**: Full semver support for packages
- **Single Dependencies**: Removed devDependencies complexity
- **Metadata Tracking**: Installation history and package information
- **Version Conflict Resolution**: Prevents duplicate package versions

### 4. **Developer Experience**
- **Dual Workflow Support**: Clear separation between creating and using commands
- **Familiar Patterns**: npm-like commands and manifest structure
- **Team Collaboration**: Share dependencies via ccm.json
- **Example Package**: Ready-to-test hello-world commands included

---

**Note**: This plan focuses on the absolute minimum features needed for a useful product. Each phase builds on the previous one, allowing for early testing and validation.