# CCM Enhanced Design: Dependency Management

## Overview
CCM will manage Claude Code commands with separation between user-created and installed commands, using a dependency manifest system similar to npm.

## Directory Structure

```
.claude/
├── commands/           # Claude Code reads from here
│   ├── my-command.md          # User-created command
│   ├── git-helper.md          # -> ../installed/git-helper.md (symlink)
│   └── code-review.md         # -> ../installed/code-review.md (symlink)
├── installed/          # CCM-managed commands (git-ignored)
│   ├── git-helper.md
│   ├── code-review.md
│   └── .ccm-metadata.json     # Installation metadata
├── ccm.json           # Dependency manifest
└── .gitignore         # Auto-generated by CCM
```

## ccm.json Format

```json
{
  "name": "my-project-commands",
  "version": "1.0.0",
  "description": "Commands for my project",
  "dependencies": {
    "git-helper": "^1.2.0",
    "code-review": "^2.0.0",
    "sql-formatter": "~1.0.0"
  },
  "devDependencies": {
    "test-utils": "^1.0.0"
  },
  "ccm": {
    "registry": "https://registry.ccm.dev",
    "installed": "./installed",
    "commands": "./commands"
  }
}
```

## Benefits

### 1. Clean Separation
- **User commands**: Tracked in git, project-specific
- **Installed commands**: Git-ignored, managed by CCM
- **Clear ownership**: Easy to see what's yours vs installed

### 2. Version Control Friendly
```gitignore
# CCM installed commands
.claude/installed/
.claude/.ccm-lock.json
```

### 3. Reproducible Environments
```bash
# New team member can get same commands
git clone project
cd project
ccm install  # Installs all dependencies from ccm.json
```

### 4. Dependency Management
```bash
ccm install git-helper@1.2.0
ccm install code-review --save-dev
ccm update
ccm audit
```

## Implementation Strategy

### Phase 1: Core Structure
1. **ccm.json management**
   - `ccm init` - Create ccm.json
   - `ccm install` - Install dependencies
   - `ccm install <package>` - Install specific package

2. **Directory management**
   - Auto-create `.claude/installed/` 
   - Auto-create `.claude/.gitignore`
   - Symlink management

### Phase 2: Advanced Features
1. **Lock file** (`.ccm-lock.json`)
   - Exact versions installed
   - Integrity hashes
   - Dependency tree

2. **Workspace support**
   - Multiple ccm.json files
   - Command inheritance
   - Namespace isolation

## Commands

### Installation
```bash
ccm init                    # Create ccm.json
ccm install                 # Install all dependencies
ccm install <package>       # Install specific package
ccm install <package> --save-dev
ccm uninstall <package>     # Remove package
ccm update                  # Update all packages
ccm update <package>        # Update specific package
```

### Information
```bash
ccm list                    # List all commands (user + installed)
ccm list --installed       # List only installed commands
ccm list --user            # List only user commands
ccm outdated               # Show outdated packages
ccm audit                  # Security audit
```

### Development
```bash
ccm link                   # Link local development package
ccm publish                # Publish to registry
ccm pack                   # Create package tarball
```

## Conflict Resolution

### Name Conflicts
If user has `git-helper.md` and tries to install `git-helper`:
1. **Error by default**: "Command 'git-helper' already exists"
2. **Force option**: `ccm install git-helper --force`
3. **Namespace option**: `ccm install git-helper --as git-helper-pkg`

### Version Conflicts
Use semantic versioning resolution:
- `^1.2.0` - Compatible with 1.2.0
- `~1.2.0` - Approximately 1.2.0
- `1.2.0` - Exact version

## Symlink Strategy

### Cross-Platform Support
- **Unix/Mac**: Use `fs.symlink()`
- **Windows**: Use junction points or copy files
- **Fallback**: Copy files if symlinks fail

### Symlink Detection
```typescript
// CLI scanner update
if (isSymlink(filePath)) {
  const target = readlink(filePath);
  const isInstalled = target.includes('/installed/');
  // Mark as installed vs user command
}
```

## Auto-Generated .gitignore

CCM automatically maintains `.claude/.gitignore`:
```gitignore
# CCM installed commands
installed/
.ccm-lock.json
*.ccm-tmp

# Keep user commands
!commands/
```

## Migration Path

### Existing Projects
1. Run `ccm init` in existing project
2. CCM scans existing commands
3. Offers to move installed commands to new structure
4. Creates ccm.json with current state

### Backward Compatibility
- Still scan legacy `.claude/commands/` structure
- Warn about old structure
- Provide migration command

## Example Workflow

```bash
# New project
mkdir my-project && cd my-project
ccm init

# Install some commands
ccm install git-helper code-review sql-formatter

# Create user command
echo "# My Command" > .claude/commands/my-command.md

# Commit to git (only user commands tracked)
git add .claude/commands/ .claude/ccm.json
git commit -m "Add project commands"

# Team member clones and gets same setup
git clone project
cd project
ccm install  # Gets same commands as defined in ccm.json
```

This approach makes CCM much more professional and follows established package management patterns while maintaining full compatibility with Claude Code's existing command system.